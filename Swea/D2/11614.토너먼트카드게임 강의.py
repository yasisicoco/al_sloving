# state 1 변영인 강사님 강의 
T = int(input())  # 테스트 케이스의 수를 입력받음


def rsp(p1, p2):  # 가위바위보를 판단하는 함수
    h1 = arr[p1]  # 첫 번째 플레이어의 선택
    h2 = arr[p2]  # 두 번째 플레이어의 선택
    if h1 == '1':  # 첫 번째 플레이어가 가위를 냈다면
        if h2 == '2':  # 두 번째 플레이어가 바위를 냈다면
            return p2  # 두 번째 플레이어가 이김
    elif h1 == '2':  # 첫 번째 플레이어가 바위를 냈다면
        if h2 == '3':  # 두 번째 플레이어가 보를 냈다면
            return p2  # 두 번째 플레이어가 이김
    elif h1 == '3':  # 첫 번째 플레이어가 보를 냈다면
        if h2 == '1':  # 두 번째 플레이어가 가위를 냈다면
            return p2  # 두 번째 플레이어가 이김
    return p1  # 위의 경우가 아니라면 첫 번째 플레이어가 이김

def tournament(start, end):  # 토너먼트를 진행하는 함수
    if start == end:  # 시작과 끝이 같다면
        return start  # 시작 인덱스를 반환
    g1 = tournament(start, (start + end) // 2)  # 첫 번째 그룹의 승자를 찾음
    g2 = tournament((start + end) // 2 + 1, end)  # 두 번째 그룹의 승자를 찾음
    return rsp(g1, g2)  # 두 그룹의 승자 중 최종 승자를 찾음

for tc in range(1, T+1):  # 각 테스트 케이스에 대해
    _ = input()  # 불필요한 입력은 무시
    arr = input().split()  # 가위바위보 선택을 입력받음
    # 1 - 가위, 2 - 바위, 3 - 보
    # answer = tournament(0, len(arr)-1)  # 토너먼트를 진행하고 승자를 찾음
    answer = tournament(len(arr)-1)  # 토너먼트를 진행하고 승자를 찾음
    print(f'#{tc} {answer+1}')  # 테스트 케이스 번호와 승자를 출력

'''
가위바위보 선택을 입력받습니다.
토너먼트를 진행하고 승자를 찾습니다. 이는 재귀적으로 이루어집니다:
- 시작과 끝이 같다면, 즉 한 명의 플레이어만 남았다면 그 플레이어가 승자입니다.
- 그렇지 않다면, 플레이어를 두 그룹으로 나누고 각 그룹의 승자를 찾습니다.
- 두 그룹의 승자 중 최종 승자를 가위바위보로 결정합니다.
테스트 케이스 번호와 승자를 출력합니다.
'''

'''
## 8명의 플레이어가 참가하는 예
- 각 플레이어는 1(가위), 2(바위), 또는 3(보) 중 하나를 선택했다고 가정
- 플레이어들의 선택을 `[1, 3, 2, 1, 2, 3, 1, 2]`로 설정

### 1단계: 전체 토너먼트 구조
[1]---\
        [1]---\
  [3]---/     \
              [1]---\
  [2]---\     /     \
        [2]---/       \
  [1]---/             \
                        [1]---\
  [2]---\             /       \
        [2]---\       /         \
  [3]---/     \     /           \
              [2]---/             \
  [1]---\     /                   \
        [1]---/                     \
  [2]---/                           \
                                    [1]
### 2단계: 분할 과정
- 전체 플레이어 그룹을 반으로 나누고, 각 그룹에서 다시 반으로 나눕니다. 이 과정을 플레이어가 한 명만 남을 때까지 계속합니다.

### 3단계: 정복 과정
- 각 대결의 승자를 결정하고, 최종적으로 한 명의 승자가 남을 때까지 승자끼리 대결을 진행합니다.

### 4단계: 승자 결정
- 최종적으로 남은 한 명이 전체 토너먼트의 승자가 됩니다. 이 예에서는 1번 플레이어가 최종 승자입니다.

### 분할정복 과정
전체 대결 구조:
[1] vs [3] => [1]
[2] vs [1] => [2]
[2] vs [3] => [2]
[1] vs [2] => [1]

중간 단계 승자 대결:
[1] vs [2] => [1]
[2] vs [1] => [1]

최종 승자 결정:
[1] vs [1] => [1]

최종 승자: 1번 플레이어

'''

# state 2 변영인 강사님 강의 
T = int(input())

def rsp(player1, player2):  # 함수의 매개변수
    # player의 카드정보를 어떻게 불러올거냐?
    # player1, player2 -> 학생들의 번호. player1 < player2
    # 번호 작은 쪽이 거의 이긴다
    card1 = cards[player1]
    card2 = cards[player2]
    winner = player1
    if card1 == '1' and card2 == '2': winner = player2  # 가-바
    if card1 == '2' and card2 == '3': winner = player2  # 바-보
    if card1 == '3' and card2 == '1': winner = player2  # 보-가
    return winner

def divide(s, e):  # i, j -> i~(i+j)//2, (i+j)//2+1~j
    # start, end
    if s == e:  # 1개씩만 존재 -> 인덱스. cards에서 쓸 수 있는 인덱스
        return s  # s,e 같은 것.
    m = (s+e)//2
    g1 = divide(s, m)
    g2 = divide(m+1, e)
    return rsp(g1, g2)

for tc in range(1, T+1):
    print(f'#{tc}', end=' ')
    _ = input()  # 안씀 -> N
    cards = input().split()  # 1,2,3 가위바위보는 숫자로 생각할 필요 X
    answer = divide(0, len(cards) - 1) + 1
    print(answer)  # 인덱스를 0부터 생각했는데...
