# state 1 변영인 강사님
T = 10  # 테스트 케이스의 수
for tc in range(1, T+1):  # 각 테스트 케이스에 대해
    print(f'#{tc}', end=' ')  # 테스트 케이스 번호를 출력
    _ = input()  # 불필요한 입력은 무시
    cal = input()  # 수식을 입력받음
    st = []  # 스택을 초기화
    new_cal = ''  # 후위 표기법으로 변환된 수식을 저장할 변수
    for c in cal:  # 수식의 각 문자에 대해
        if c not in '+*':  # 숫자라면
            new_cal += c  # 후위 표기법 수식에 추가
        else:  # 연산자라면
            if not st:  # 스택이 비어있다면
                st.append(c)  # 연산자를 스택에 추가
                continue
            top = st[-1]  # 스택의 맨 위 요소를 확인
            if not (top == '+' and c == '*'):  # 우선순위를 고려하여
                while st and not (st[-1] == '+' and c == '*'):  # 스택에서 연산자를 꺼내 후위 표기법 수식에 추가
                    new_cal += st.pop()
            st.append(c)  # 현재 연산자를 스택에 추가
    while st:  # 스택에 남아있는 연산자를 모두 꺼내 후위 표기법 수식에 추가
        new_cal += st.pop()
    st.clear()  # 스택을 초기화
    for c in new_cal:  # 후위 표기법 수식의 각 문자에 대해
        if c not in '+*':  # 숫자라면
            st.append(int(c))  # 스택에 추가
        else:  # 연산자라면
            pop1 = st.pop()  # 스택에서 두 개의 숫자를 꺼내
            pop2 = st.pop()
            if c == '+':  # 덧셈이라면
                st.append(pop2 + pop1)  # 더한 결과를 스택에 추가
            else:  # 곱셈이라면
                st.append(pop2 * pop1)  # 곱한 결과를 스택에 추가
    print(st[-1])  # 스택의 맨 위에 있는 최종 결과를 출력


'''
불필요한 입력을 무시하고, 수식을 입력받습니다.
스택을 초기화하고, 후위 표기법으로 변환된 수식을 저장할 변수를 초기화합니다.
수식의 각 문자에 대해 다음을 수행합니다:
- 숫자라면 후위 표기법 수식에 추가합니다.
- 연산자라면 스택이 비어있는지 확인하고, 비어있다면 연산자를 스택에 추가합니다.
- 스택이 비어있지 않다면, 스택의 맨 위 요소를 확인하고, 우선순위를 고려하여 스택에서 연산자를 꺼내 후위 표기법 수식에 추가합니다.
- 현재 연산자를 스택에 추가합니다.
스택에 남아있는 연산자를 모두 꺼내 후위 표기법 수식에 추가합니다.
스택을 초기화합니다.
후위 표기법 수식의 각 문자에 대해 다음을 수행합니다:
- 숫자라면 스택에 추가합니다.
- 연산자라면 스택에서 두 개의 숫자를 꺼내 연산한 후 결과를 스택에 추가합니다.
스택의 맨 위에 있는 최종 결과를 출력합니다.
'''

'''
이 코드에서는 스택을 사용하여 연산자의 우선순위를 고려합니다.
스택의 특성을 이용하여 후위 표기법으로 변환하는 과정에서 연산자의 우선순위를 관리합니다.
- 곱셈('*')은 덧셈('+')보다 우선순위가 높습니다.
- 같은 우선순위의 연산자는 왼쪽에서 오른쪽으로 순서대로 계산됩니다.

* 스택의 맨 위에 있는 연산자(top)와 현재 처리하려는 연산자(c)를 비교합니다.
* 만약 top이 '+'이고 c가 ''라면, ''의 우선순위가 더 높으므로 c를 스택에 추가합니다.
* 그렇지 않다면, 즉 top이 ''이거나 c가 '+'라면, 스택에서 연산자를 꺼내 후위 표기법 수식에 추가합니다. 이는 ''의 우선순위가 더 높거나, 같은 우선순위의 연산자가 왼쪽에서 오른쪽으로 순서대로 계산되어야 하기 때문입니다.
* 이 과정을 반복하면, 스택에는 항상 우선순위가 높은 연산자가 먼저 저장되고, 후위 표기법 수식에는 우선순위를 고려한 순서대로 연산자가 추가됩니다.
'''

'''
## 후위 표기식 변환과 계산 과정
예) `2+3*4`의 변환 과정 :  `+`와 `*` 연산자를 포함하고 있으며, `*` 연산자가 `+`보다 높은 우선순위를 가집니다.

### 1단계: 수식 입력
- 입력된 수식: `2+3*4`

### 2단계: 후위 표기법 변환 과정
- 초기 상태:
  - 입력 수식: `2+3*4`
  - 스택: `[]`
  - 후위 표기법 수식: ``

- `2` 처리:
  - 입력: `+3*4`
  - 스택: `[]`
  - 후위 표기법 수식: `2`

- `+` 처리:
  - 입력: `3*4`
  - 스택: `[+]`
  - 후위 표기법 수식: `2`

- `3` 처리:
  - 입력: `*4`
  - 스택: `[+]`
  - 후위 표기법 수식: `23`

- `*` 처리 (우선순위가 더 높으므로 `+`보다 먼저 스택에 들어감):
  - 입력: `4`
  - 스택: `[+,*]`
  - 후위 표기법 수식: `23`

- `4` 처리:
  - 입력: ``
  - 스택: `[+,*]`
  - 후위 표기법 수식: `234`

- 스택 처리 (스택에 남아 있는 연산자를 모두 꺼냄):
  - 입력: ``
  - 스택: `[]`
  - 후위 표기법 수식: `234*+`

### 3단계: 후위 표기법 계산 과정
- 후위 표기법 수식: `234*+`
- 스택: `[]`

- 숫자들(`2`, `3`, `4`)을 스택에 순서대로 넣고, 연산자(`*`, `+`)를 만나면 스택에서 숫자를 두 개 꺼내 연산을 수행한 후 결과를 다시 스택에 넣습니다.
'''



# state 2 변영인 강사님 
# T = 10  # -> 10개 주어짐
# for tc in range(1, T+1):
#     print(f'#{tc}', end=' ')
#     _ = input()  # 전체 식의 길이
#     cal = input()  # 조작 안하고 단순 for문 쓸거면 굳이 list X
#     # +랑 *가 섞여있어서 map(int 적절하지 X)
#     postfix = ''
#     st = []  # 스택
#     for c in cal:  # 계산식을 앞으로부터 탐색
#         # 1.
#         # 후위표기식 -> 연산자가 뒤로 오게...
#         if c not in '+*':  # + 또는 * (연산자)가 아닐 것
#             # 숫자일 것
#             postfix += c  # 숫자는 그냥 새로운 식에 추가
#         # 연산자
#         else:
#             if not st:  # 스택비어있으면 채워야지
#                 st.append(c)  # push
#                 continue
#             # 스택이 빈 상태면 현재 라인에 접근 X
#             # + * => + +, + *, *, *
#             # 스택 맨위에가 +가 아니고 탐색중인 글자가 *이 아님
#             # 우선순위 문제가 없다면 ++, **, *+
#             #  스택에서 가장 밖에/최신에 있는 데이터
#             if not (st[-1] == '+' and c == '*'):
#                 # top != '+' or top != '*'
#                 # (기존에 스택에 존재하던 연산자가)
#                 # 우선순위가 더 높은 연산자를 만난게 아니라면
#                 while st and not (st[-1] == '+' and c == '*'):
#                     postfix += st.pop()
#             st.append(c)
#             # 새롭게 들어오려는 *이 +를 눌러버리는 효과
#             # 나중에 같은 *이 들어오면 어차파 띠쳐나갈 거지만...
#             # 스택 상에 존재하는 +의 경우엔 마주치게 되면...
#     while st: # 끝으로 스택 안에 잔존하는 연산자들을 식으로 이동
#         postfix += st.pop()
#     # 2.
#     # 후위표기식 -> stack을 통해서 피연산자1, 2를 pop()하고
#     # 나중에 pop된 것 -> 왼쪽 + 연산자 + 먼저 pop된 것 오른쪽
#     # -> 연산 후 다시 stack에 넣고.... 최종적으로 가장 스택에
#     # 마지막으로 남은...
#     st.clear()
#     for p in postfix:
#         if p not in '+*':
#             st.append(int(p))  # 숫자
#         else:
#             pop1 = st.pop()
#             pop2 = st.pop()
#             if p == '+':
#                 st.append(pop2 + pop1)
#             elif p == '*':
#                 st.append(pop2 * pop1)
#     print(st[-1])